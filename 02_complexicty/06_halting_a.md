## Неразрешимость Halting Problem.

Алгоритмически неразрешимая задача - задача, для которой нет решения 
(не существует алгоритма, который можно было бы запустить на входных данных и получить верный ответ на задачу).

Классический пример - ***Halting Problem*** (*проблема оставнова*) - Дана программа - остановится ли она когда-нибудь?

Почему же она алгоритмически неразрешима?

Пусть разрешима.
Тогда существует алгоритм *terminate*, который принимает входные данные (программу + её входные данные) и говорит, остановится она или нет.
Рассмотрим такую программу:
```
def inv(code):
   if terminate(code, code):
      while(true)
```
Если `inv(inv)` должна завершиться, то `terminate(inv, inv)` должна вернуть `true`. Тогда `inv(inv)` должна зависнуть в бесконечном цикле.
Если `inv(inv)` недолжна завершиться, то `terminate(inv, inv)` должна вернуть `false`. Тогда `inv(inv)` должна завершиться. Ой...

## Понятие Decision, Search задачи, языка.

Но гораздо интереснее задачи, которые можно решить алгоритмом.
Они делятся на 2 класса - **Decision** и **Search**.

Задача **Decision** - если ответ на неё это "да" или "нет".
Если же в задаче надо что-то найти, то она **Search**.

Примеры задач:
 * Decision. Проверить, есть ли *x* в массиве *a*.
 * Search. Найти позицию *x* в массиве *a*.
 * Decision. Проверить, есть ли путь из *a* в *b* в графе *G*.
 * Search. Найти сам путь.
 * Decision. Проверить, есть ли в графе клика размера хотя бы *k*.
 * Search. Найти максимальный размер клики (или саму клику).
 
**Decision** задачу *f* можно также задать языком (множеством слов): L = {*x*: *f(x)* = true}.

## Определения DTime, P, EXP.

**DTime( f(n) )** = {L | существует детерминированный алгоритм, за O( f(n) ) отвечающая да/нет}.

**P** - класс задач, в который входят задачи, имеющие решение за полиномиальное время работы.

**EXP** - класс задач, в который входят задачи, имеющие решение за экспоненциальное время работы.

*строгое мат. определение см. в конспекте*

## Cледствие P ̸= EXP из теоремы об иерархии по времени.

**Th**: f << g -> DTime(f) *входит в* DTime(g) (но не совпадает)

Ещё одна формулировка - DTime(f) *входит(ннс) в* DTime(f \log^2 f)

**Доказательство...** Задача, которую нельзя решить за *f(n)*: завершится ли данная программа за *f(n) log f(n)* шагов. 

Очень важное следствие из неё: **P** < DTime(2^n) *входит(ннс) в* DTime(2^2n) *входит в* **EXP** -> **P** != **EXP**




















