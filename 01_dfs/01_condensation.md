## DFS. Компоненты сильной связности. Конденсация.
КСС - от любой вершины в компоненте есть путь до любой другой вершины в компоненте

Конденсация - построение графа, где вершина соответствует КСС исходного

Алгоритм за O(V+E):

* Обойдём все вершины
  * Для каждой вершниы
    пометим её,
    запустимся рекурсивно от всех вершин в которые идут рёбра,
    добавим в начало списка Order
  * Если вершина уже помечена, ничего не делаем
* Получили "Есть путь v ~> u, но нет u ~> v => v в Order раньше u"
* Пройдём по списку Order
  * Для каждой вершины
    запустим DFS по обратным рёбрам, заходящий только в вершины для которых ещё не найдеты компонентны,
     то, что он достиг относим к компоненте этой вершины
* DFS достиг v из u по обратным рёбрам => есть путь v ~> u. При этом, если v не принадлежит компоненте, значит u в Order стоит раньше v, что невозможно если нет пути u ~> v.

*Замечание*: Добавить в начало и пройти по порядку <=> добавить в конец и пройти в обратном порядке

```c++

vector<int> order;
bool marked[|V|];
int component[|V|];
int curComponentID = 1;
void condense() {
    for(int v : V) {
        if(!marked[v]) {
            dfs1(v);
        }   
    }
    for(int v : reverse(order)) {
        if(component[v] == 0) {
            dfs2(v, curComponentID++);
        }
    }
}

void dfs1(int v) {    
    marked[v] = true;
    for(int u : out[v]) {
        if(!marked[u]) {
            dfs1(u);
        }
    }
    order.push_back(v);
}

void dfs2(int v, int id) { 
    component[v] = id;
    for(int u : in[v]) {
        if(component[u] == 0) {
            dfs2(u, id);
        }
    }
}

```
